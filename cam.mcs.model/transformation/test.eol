var rand = new Native("java.util.Random");
var system = new MCSystem;
var core = new Core;
init();
getRandomTaskSet(20, 0.5);
run(1000);
'run over.'.println();


//////////////////////////////////////////////
operation init() {
	system.criticality = Criticality#low;
	system.ceiling_priority = 1;
	system.status = Status#LOW;	
	core.time = 0;
	system.core = core;
}

operation run(N : Integer) {
	for(i in Sequence{0..N}) {
		tick();	
		core.time.execute();
		print_status();
	}
}


//implement
operation Integer execute() {
	for(t in system.taskSet.tasks) {
		//handles task releases
		if(t.release_time = self) {
			release_task(t);
		}
		handle_current();
	}
}

//handles current task
operation handle_current() {
	var t = core.current_task;
	if(t.isDefined()) {
		var curr = core.time;
		//non-critical section
		if(t.current_cs = 0) {
			var enter = t.critical_sections.at(0).start;
			if(t.release_time + enter = curr) {
				//enter critical section
				t.current_cs = 1;
				var cs = t.critical_sections.at(0);
				//acquire_lock
				acquire_lock(t, cs.semaphore);
				//handle ceiling priority
			}
		}
		else {
			var cs = t.critical_sections.at(t.current_cs);
			var elapsed = cs.elapsed;
			//if still in critical section, elapse ++;
			if(elapsed <= cs.execution) {
				cs.elapsed ++;
			}
			//if should exit critical section
			else {
				t.current_cs++;
				//return to original priority
				
			}
		}
		//critical section
		if(t.deadline = curr - t.release_time) {
			core.queue.add(t);
			t.release_time = curr + t.period;
			core.current_task = null;
		}
	}
	
}

operation release_task(task) {
	var t = core.current_task; //current running task
	if(t.isUndefined()) {
		core.current_task = task;
		system.ceiling_priority = task.priority;
	}
	else {
		//shall preempt
		if(system.ceiling_priority < task.priority) {
			core.queue.add(t);
			core.curren_task = task;
			system.ceiling_priority = task.priority;
		}
		//shall wait
	}
}

operation tick() {
	core.time += 1;
}

operation acquire_lock(task, semaphore) {
	if(sempahore.locked)
		return false;
	else {
		semaphore.locked = true;
		semaphore.acquisition = task;
	}
}

operation release_lock(task, semaphore) {
	if(semaphore.acquisition = task) {
		semaphore.locked = false;
		return true;
	}
	return false;
}

operation TaskSet createOneTask(i : Integer){
	var index = i.asString();
	var sem = createSemaphore("R"+index, false, 1, 3);
	var task = createTask("T"+index, 1, 1, 1, 1, 1, 1, 1, 1); 
	task.add_resource(sem);
	task.set_release_time(getRandomInt(20));
	self.tasks.add(task);
	return task;
}

operation getRandomTaskSet(n : Integer, U : Real){
	var taskSet = createTaskSet();
	var sum_u = U;
	taskSet.task_number = n;
	taskSet.u = U.asDouble();
	for (i in Sequence{0..n}) {
		var task = taskSet.createOneTask(i);
		task.utilisation = getRemainingUtilization(sum_u, n, i);
		sum_u -= task.utilisation;
		task.period = getRandomInt(1000);
		task.computation_time = task.period * task.utilisation;
		task.deadline = task.period;
	}
}

operation getRandomInt(n){
	var rand = new Native("java.util.Random");
	return rand.nextInt(n);
}

operation getRemainingUtilization(sum_u, n, i){
	var p = getRandomDecimal();
	return sum_u * (1 - p.pow(1.0/(n-i)));
}

operation getRandomDecimal(){
	var rand = new Native("java.util.Random");
	return rand.nextInt(100000).asReal()/100000;
}

operation createTaskSet(){
	var taskSet = new TaskSet;
	taskSet.task_number = 0;
	system.taskSet = taskSet;
	return taskSet;
}

operation createCriticalSection(name, start, execution, sem) {
	var cs = new CriticalSection;
	cs.name = name;
	cs.start = start; //relative start time
	cs.execution = execution; //execution time in critical section
	cs.elapsed = 0; //time elapsed in the critical section
	cs.semaphore = sem; // semaphore acquired by this critical section
	return cs;
}

operation createTask(name, pri, T, d, wl, wh, l, dp, of) {
	var task = new Task;
	task.name = name;
	task.priority = pri; //priority
	task.period = T; //period
	task.deadline = d; //deadline
	task.wcet_low = wl; //wcet in low mode
	task.wcet_high = wh; //wcet in high mode
	task.dynamic_priority = dp; //dynamic priority
	task.offset = of; //initial  offset
	task.current_cs = -1; //current cs, -1 means not in critical sections, 0, 1, 2 means index of critical section
	system.tasks.add(task); //add this task to the system
	return task;
}

operation Task add_resource(sem) {
	var cs = createCriticalSection("cs", 2, 3, sem);
	sem.acquisition = self;
	self.critical_sections.add(cs);
}

operation Task set_release_time(time) {
	self.release_time = time;
} 

operation createSemaphore(name, locked, initial, ceiling) {
	var sem = new Semaphore;
	sem.name = name;
	sem.locked = locked; 
	sem.initial_priority = initial;
	sem.ceiling_priority = ceiling;
	system.resources.add(sem);
	return sem;
}

operation print_status() {
	var time = core.time;
	var task = "null";
	if(core.current_task.isDefined())
		task = core.current_task.name;
	var queue = core.queue.collect(n|n.name);
	("timestampe:   " + time + "\n" + "current task: " + task + "\n" + queue + "\n").println();
}